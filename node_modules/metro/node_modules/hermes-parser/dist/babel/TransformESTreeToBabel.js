/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformProgram = transformProgram;

var _SimpleTransform = require("../transform/SimpleTransform");

var _SimpleTraverser = require("../traverse/SimpleTraverser");

var _ESTreeVisitorKeys = _interopRequireDefault(require("../generated/ESTreeVisitorKeys"));

var _createSyntaxError = require("../utils/createSyntaxError");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Rely on the mapper to fix up parent relationships.
const EMPTY_PARENT = null;
const FlowESTreeAndBabelVisitorKeys = { ..._ESTreeVisitorKeys.default,
  BigIntLiteral: [],
  BlockStatement: ['directives', ..._ESTreeVisitorKeys.default.BlockStatement],
  BooleanLiteral: [],
  ClassMethod: ['key', 'params', 'body', 'returnType', 'typeParameters'],
  ClassPrivateMethod: ['key', 'params', 'body', 'returnType', 'typeParameters'],
  ClassProperty: ['key', 'value', 'typeAnnotation', 'variance'],
  ClassPrivateProperty: ['key', 'value', 'typeAnnotation', 'variance'],
  Directive: ['value'],
  DirectiveLiteral: [],
  ExportNamespaceSpecifier: ['exported'],
  File: ['program', 'comments'],
  Import: [],
  NullLiteral: [],
  NumericLiteral: [],
  ObjectMethod: [..._ESTreeVisitorKeys.default.Property, 'params', 'body', 'returnType', 'typeParameters'],
  ObjectProperty: _ESTreeVisitorKeys.default.Property,
  OptionalCallExpression: ['callee', 'arguments', 'typeArguments'],
  OptionalMemberExpression: ['object', 'property'],
  PrivateName: ['id'],
  Program: ['directives', ..._ESTreeVisitorKeys.default.Program],
  RegExpLiteral: [],
  RestElement: [..._ESTreeVisitorKeys.default.RestElement, 'typeAnnotation'],
  StringLiteral: [],
  CommentBlock: [],
  CommentLine: []
};

function nodeWith(node, overrideProps) {
  return _SimpleTransform.SimpleTransform.nodeWith(node, overrideProps, FlowESTreeAndBabelVisitorKeys);
}
/**
 * Babel node types
 *
 * Copied from: https://github.com/babel/babel/blob/main/packages/babel-types/src/ast-types/generated/index.ts
 */


function fixSourceLocation(node, _options) {
  const loc = node.loc;

  if (loc == null) {
    return;
  } // $FlowExpectedError[cannot-write]


  node.loc = {
    start: loc.start,
    end: loc.end
  };

  if (node.type === 'Identifier') {
    // $FlowExpectedError[prop-missing]
    node.loc.identifierName = node.name;
  } // $FlowExpectedError[prop-missing]


  node.start = node.range[0]; // $FlowExpectedError[prop-missing]

  node.end = node.range[1]; // $FlowExpectedError[cannot-write]

  delete node.range; // $FlowExpectedError[cannot-write]
  // $FlowExpectedError[prop-missing]

  delete node.parent;
}

function mapNodeWithDirectives(node) {
  // $FlowExpectedError[prop-missing]
  if (node.directives != null) {
    return node;
  }

  const directives = [];

  for (const child of node.body) {
    if (child.type === 'ExpressionStatement' && child.directive != null) {
      // Construct Directive node with DirectiveLiteral value
      directives.push({
        type: 'Directive',
        value: {
          type: 'DirectiveLiteral',
          value: child.directive,
          extra: {
            rawValue: child.directive,
            raw: child.expression.type === 'Literal' ? child.expression.raw : ''
          },
          loc: child.expression.loc,
          range: child.expression.range,
          parent: EMPTY_PARENT
        },
        loc: child.loc,
        range: child.range,
        parent: node
      });
    } else {
      // Once we have found the first non-directive node we know there cannot be any more directives
      break;
    }
  } // Move directives from body to new directives array
  // $FlowExpectedError[incompatible-call] We are adding properties for babel that don't exist in the ESTree types.


  return nodeWith(node, {
    directives,
    body: directives.length === 0 ? node.body : node.body.slice(directives.length)
  });
}

function mapProgram(node) {
  var _program$directives;

  // Visit child nodes and convert to directives
  const program = mapNodeWithDirectives(node); // Adjust start loc to beginning of file

  const startLoc = {
    line: 1,
    column: 0
  }; // Adjust end loc to include last comment if program ends with a comment

  let endLoc = program.loc.end;
  let endRange = program.range[1];

  if (program.comments.length > 0) {
    const lastComment = program.comments[program.comments.length - 1];

    if (lastComment.range[1] > endRange) {
      endLoc = lastComment.loc.end;
      endRange = lastComment.range[1];
    }
  }

  const loc = {
    start: startLoc,
    end: endLoc
  };
  const range = [0, endRange];
  const babelComments = program.comments.map(comment => {
    switch (comment.type) {
      case 'Line':
        {
          return {
            type: 'CommentLine',
            value: comment.value,
            loc: comment.loc,
            range: comment.range
          };
        }

      case 'Block':
        {
          return {
            type: 'CommentBlock',
            value: comment.value,
            loc: comment.loc,
            range: comment.range
          };
        }
    }
  }); // Rename root node to File node and move Program node under program property

  return {
    type: 'File',
    // $FlowExpectedError[prop-missing] Comments, docblock and tokens are purposely missing to match the Babel AST.
    program: {
      type: 'Program',
      body: program.body,
      // $FlowExpectedError[prop-missing] This is added by `mapNodeWithDirectives`
      directives: (_program$directives = program.directives) != null ? _program$directives : [],
      sourceType: program.sourceType,
      interpreter: program.interpreter,
      // TODO: Add back for BABEL?
      // sourceFile: options.sourceFilename,
      loc,
      range,
      parent: EMPTY_PARENT
    },
    comments: babelComments,
    loc,
    range,
    parent: EMPTY_PARENT
  };
}

function mapTemplateElement(node) {
  // Adjust start loc to exclude "`" at beginning of template literal if this is the first quasi,
  // otherwise exclude "}" from previous expression.
  const startCharsToExclude = 1; // Adjust end loc to exclude "`" at end of template literal if this is the last quasi,
  // otherwise exclude "${" from next expression.

  const endCharsToExclude = node.tail ? 1 : 2; // Mutate the existing node to use the new location information.
  // NOTE: because we don't add any new properties here we cannot detect if this change has been
  //       made, so its important we don't return a new node other wise it will recursive infinitely.
  // $FlowExpectedError[cannot-write]

  node.loc = {
    start: {
      line: node.loc.start.line,
      column: node.loc.start.column + startCharsToExclude
    },
    end: {
      line: node.loc.end.line,
      column: node.loc.end.column - endCharsToExclude
    }
  }; // $FlowExpectedError[cannot-write]

  node.range = [node.range[0] + startCharsToExclude, node.range[1] - endCharsToExclude];
  return node;
}

function mapProperty(node) {
  const key = node.key;
  const value = node.value; // Convert methods, getters, and setters to ObjectMethod nodes

  if (node.method || node.kind !== 'init') {
    if (value.type !== 'FunctionExpression') {
      throw (0, _createSyntaxError.createSyntaxError)(node, `Invalid method property, the value must be a "FunctionExpression" or "ArrowFunctionExpression. Instead got "${value.type}".`);
    } // Properties under the FunctionExpression value that should be moved
    // to the ObjectMethod node itself.


    const newNode = {
      type: 'ObjectMethod',
      // Non getter or setter methods have `kind = method`
      kind: node.kind === 'init' ? 'method' : node.kind,
      method: node.kind === 'init' ? true : false,
      computed: node.computed,
      key: key,
      id: null,
      params: value.params,
      body: value.body,
      async: value.async,
      generator: value.generator,
      returnType: value.returnType,
      typeParameters: value.typeParameters,
      loc: node.loc,
      range: node.range,
      parent: node.parent
    };

    if (node.kind !== 'init') {
      // babel emits an empty variance property on accessors for some reason
      // $FlowExpectedError[cannot-write]
      newNode.variance = null;
    }

    return newNode;
  } // Non-method property nodes should be renamed to ObjectProperty


  return {
    type: 'ObjectProperty',
    computed: node.computed,
    key: node.key,
    // $FlowExpectedError[incompatible-cast]
    value: node.value,
    method: node.method,
    shorthand: node.shorthand,
    loc: node.loc,
    range: node.range,
    parent: node.parent
  };
}

function mapMethodDefinition(node) {
  const value = node.value;
  const BaseClassMethod = {
    kind: node.kind,
    computed: node.computed,
    static: node.static,
    key: node.key,
    id: null,
    // Properties under the FunctionExpression value that should be moved
    // to the ClassMethod node itself.
    params: value.params,
    body: value.body,
    async: value.async,
    generator: value.generator,
    returnType: value.returnType,
    typeParameters: value.typeParameters,
    predicate: null,
    loc: node.loc,
    range: node.range,
    parent: node.parent
  };

  if (node.key.type === 'PrivateIdentifier') {
    return { ...BaseClassMethod,
      type: 'ClassPrivateMethod'
    };
  }

  return { ...BaseClassMethod,
    type: 'ClassMethod'
  };
}

function mapExportAllDeclaration(node) {
  if (node.exported != null) {
    return {
      type: 'ExportNamedDeclaration',
      declaration: null,
      specifiers: [{
        type: 'ExportNamespaceSpecifier',
        exported: node.exported,
        // The hermes AST emits the location as the location of the entire export
        // but babel emits the location as *just* the "* as id" bit.
        // The end will always align with the end of the identifier (ezpz)
        // but the start will align with the "*" token - which we can't recover from just the AST
        // so we just fudge the start location a bit to get it "good enough"
        // it will be wrong if the AST is anything like "export      * as x from 'y'"... but oh well
        loc: {
          start: {
            column: node.loc.start.column + 'export '.length,
            line: node.loc.start.line
          },
          end: node.exported.loc.end
        },
        range: [node.range[0] + 'export '.length, node.exported.range[1]],
        parent: EMPTY_PARENT
      }],
      source: node.source,
      exportKind: node.exportKind,
      loc: node.loc,
      range: node.range,
      parent: node.parent
    };
  } // $FlowExpectedError[cannot-write]


  delete node.exported;
  return node;
}

function mapRestElement(node) {
  // ESTree puts type annotations on rest elements on the argument node,
  // but Babel expects type annotations on the rest element node itself.
  const argument = node.argument;

  if ((argument.type === 'Identifier' || argument.type === 'ObjectPattern' || argument.type === 'ArrayPattern') && argument.typeAnnotation != null) {
    // Unfortunately there's no way for us to recover the end location of
    // the argument for the general case
    const argumentRange = argument.range;
    let argumentLoc = argument.loc;

    if (argument.type === 'Identifier') {
      argumentRange[1] = argumentRange[0] + argument.name.length;
      argumentLoc = {
        start: argumentLoc.start,
        end: {
          line: argumentLoc.start.line,
          column: argumentLoc.start.column + argument.name.length
        }
      };
    }

    return nodeWith(node, {
      typeAnnotation: argument.typeAnnotation,
      argument: nodeWith(argument, {
        typeAnnotation: null,
        range: argumentRange,
        loc: argumentLoc
      })
    });
  }

  return node;
}

function mapImportExpression(node) {
  // Babel expects ImportExpression to be structured as a regular
  // CallExpression where the callee is an Import node.
  // $FlowExpectedError[prop-missing] optional and typeArguments are missing to match existing output.
  return {
    type: 'CallExpression',
    // $FlowExpectedError[incompatible-return] This is a babel specific node
    callee: {
      type: 'Import',
      loc: {
        start: node.loc.start,
        end: {
          line: node.loc.start.line,
          column: node.loc.start.column + 'import'.length
        }
      },
      range: [node.range[0], node.range[0] + 'import'.length],
      parent: EMPTY_PARENT
    },
    arguments: [node.source],
    loc: node.loc,
    range: node.range,
    parent: node.parent
  };
}

function mapPrivateIdentifier(node) {
  return {
    type: 'PrivateName',
    id: {
      type: 'Identifier',
      name: node.name,
      optional: false,
      typeAnnotation: null,
      loc: {
        start: {
          line: node.loc.start.line,
          // babel doesn't include the hash in the identifier
          column: node.loc.start.column + 1
        },
        end: node.loc.end
      },
      range: [node.range[0] + 1, node.range[1]],
      paren